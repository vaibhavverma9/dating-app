{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport Animated from \"react-native-reanimated\";\nimport { State } from \"react-native-gesture-handler\";\nimport { snapPoint } from \"./Animations\";\nvar Clock = Animated.Clock,\n    Value = Animated.Value,\n    event = Animated.event,\n    add = Animated.add,\n    block = Animated.block,\n    cond = Animated.cond,\n    eq = Animated.eq,\n    multiply = Animated.multiply,\n    set = Animated.set,\n    stopClock = Animated.stopClock,\n    and = Animated.and,\n    not = Animated.not,\n    clockRunning = Animated.clockRunning,\n    startClock = Animated.startClock,\n    neq = Animated.neq,\n    call = Animated.call,\n    reDecay = Animated.decay,\n    reSpring = Animated.spring,\n    onChange = Animated.onChange,\n    debug = Animated.debug;\nexport var withScaleOffset = function withScaleOffset(value, state) {\n  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Value(1);\n  return cond(eq(state, State.END), [set(offset, multiply(offset, value)), offset], multiply(offset, value));\n};\nexport var withOffset = function withOffset(value, state) {\n  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Value(0);\n  return cond(eq(state, State.END), [set(offset, add(offset, value)), offset], add(offset, value));\n};\nexport var withSpring = function withSpring(props) {\n  var _offset$props = _objectSpread({\n    offset: new Value(0)\n  }, props),\n      value = _offset$props.value,\n      velocity = _offset$props.velocity,\n      state = _offset$props.state,\n      snapPoints = _offset$props.snapPoints,\n      offset = _offset$props.offset,\n      springConfig = _offset$props.config,\n      onSnap = _offset$props.onSnap;\n\n  var clock = new Clock();\n  var springState = {\n    finished: new Value(0),\n    velocity: new Value(0),\n    position: new Value(0),\n    time: new Value(0)\n  };\n\n  var config = _objectSpread({\n    toValue: new Value(0),\n    damping: 6,\n    mass: 1,\n    stiffness: 64,\n    overshootClamping: false,\n    restSpeedThreshold: 0.01,\n    restDisplacementThreshold: 0.01\n  }, springConfig);\n\n  var gestureAndAnimationIsOver = new Value(1);\n  var isSpringInterrupted = and(eq(state, State.BEGAN), clockRunning(clock));\n  var finishSpring = [set(offset, springState.position), stopClock(clock), set(gestureAndAnimationIsOver, 1)];\n  var snap = onSnap ? [cond(clockRunning(clock), call([springState.position], onSnap))] : [];\n  return block([cond(isSpringInterrupted, finishSpring), cond(gestureAndAnimationIsOver, set(springState.position, offset)), cond(neq(state, State.END), [set(gestureAndAnimationIsOver, 0), set(springState.finished, 0), set(springState.position, add(offset, value))]), cond(and(eq(state, State.END), not(gestureAndAnimationIsOver)), [cond(and(not(clockRunning(clock)), not(springState.finished)), [set(springState.velocity, velocity), set(springState.time, 0), set(config.toValue, snapPoint(springState.position, velocity, snapPoints)), startClock(clock)]), reSpring(clock, springState, config), cond(springState.finished, [].concat(snap, finishSpring))]), springState.position]);\n};\nexport var withDecay = function withDecay(config) {\n  var _offset$deceleration$ = _objectSpread({\n    offset: new Value(0),\n    deceleration: 0.998\n  }, config),\n      value = _offset$deceleration$.value,\n      velocity = _offset$deceleration$.velocity,\n      state = _offset$deceleration$.state,\n      offset = _offset$deceleration$.offset,\n      deceleration = _offset$deceleration$.deceleration;\n\n  var clock = new Clock();\n  var decayState = {\n    finished: new Value(0),\n    velocity: new Value(0),\n    position: new Value(0),\n    time: new Value(0)\n  };\n  var isDecayInterrupted = and(eq(state, State.BEGAN), clockRunning(clock));\n  var finishDecay = [set(offset, decayState.position), stopClock(clock)];\n  return block([cond(isDecayInterrupted, finishDecay), cond(neq(state, State.END), [set(decayState.finished, 0), set(decayState.position, add(offset, value))]), cond(eq(state, State.END), [cond(and(not(clockRunning(clock)), not(decayState.finished)), [set(decayState.velocity, velocity), set(decayState.time, 0), startClock(clock)]), reDecay(clock, decayState, {\n    deceleration: deceleration\n  }), cond(decayState.finished, finishDecay)]), decayState.position]);\n};\nexport var onScrollEvent = function onScrollEvent(contentOffset) {\n  return event([{\n    nativeEvent: {\n      contentOffset: contentOffset\n    }\n  }]);\n};\nexport var onGestureEvent = function onGestureEvent(nativeEvent) {\n  var gestureEvent = event([{\n    nativeEvent: nativeEvent\n  }]);\n  return {\n    onHandlerStateChange: gestureEvent,\n    onGestureEvent: gestureEvent\n  };\n};\nexport var panGestureHandler = function panGestureHandler() {\n  var x = new Value(0);\n  var translationX = new Value(0);\n  var velocityX = new Value(0);\n  var y = new Value(0);\n  var translationY = new Value(0);\n  var velocityY = new Value(0);\n  var state = new Value(State.UNDETERMINED);\n  var gestureHandler = onGestureEvent({\n    x: x,\n    translationX: translationX,\n    velocityX: velocityX,\n    y: y,\n    translationY: translationY,\n    velocityY: velocityY,\n    state: state\n  });\n  return {\n    x: x,\n    translationX: translationX,\n    velocityX: velocityX,\n    y: y,\n    translationY: translationY,\n    velocityY: velocityY,\n    state: state,\n    gestureHandler: gestureHandler\n  };\n};\nexport var horizontalPanGestureHandler = function horizontalPanGestureHandler() {\n  var x = new Value(0);\n  var translationX = new Value(0);\n  var velocityX = new Value(0);\n  var state = new Value(State.UNDETERMINED);\n  var gestureHandler = onGestureEvent({\n    translationX: translationX,\n    velocityX: velocityX,\n    state: state\n  });\n  return {\n    x: x,\n    translationX: translationX,\n    state: state,\n    velocityX: velocityX,\n    gestureHandler: gestureHandler\n  };\n};\nexport var verticalPanGestureHandler = function verticalPanGestureHandler() {\n  var y = new Value(0);\n  var translationY = new Value(0);\n  var velocityY = new Value(0);\n  var state = new Value(State.UNDETERMINED);\n  var gestureHandler = onGestureEvent({\n    y: y,\n    translationY: translationY,\n    velocityY: velocityY,\n    state: state\n  });\n  return {\n    y: y,\n    translationY: translationY,\n    state: state,\n    velocityY: velocityY,\n    gestureHandler: gestureHandler\n  };\n};\nexport var debugGestureState = function debugGestureState(label, state) {\n  var d = function d(value) {\n    return debug(label, new Value(value));\n  };\n\n  return onChange(state, cond(eq(state, State.UNDETERMINED), d(\"UNDETERMINED\"), cond(eq(state, State.BEGAN), d(\"BEGAN\"), cond(eq(state, State.ACTIVE), d(\"ACTIVE\"), cond(eq(state, State.END), d(\"END\"), cond(eq(state, State.CANCELLED), d(\"CANCELLED\"), d(\"FAILED\")))))));\n};","map":{"version":3,"sources":["Gesture.ts"],"names":["Clock","Value","event","add","block","cond","eq","multiply","set","stopClock","and","not","clockRunning","startClock","neq","call","decay","reDecay","spring","reSpring","onChange","debug","Animated","withScaleOffset","offset","State","withOffset","withSpring","value","velocity","state","snapPoints","springConfig","onSnap","clock","springState","finished","position","time","config","toValue","damping","mass","stiffness","overshootClamping","restSpeedThreshold","restDisplacementThreshold","gestureAndAnimationIsOver","isSpringInterrupted","finishSpring","snap","snapPoint","withDecay","deceleration","decayState","isDecayInterrupted","finishDecay","onScrollEvent","nativeEvent","contentOffset","onGestureEvent","gestureEvent","onHandlerStateChange","panGestureHandler","x","translationX","velocityX","y","translationY","velocityY","gestureHandler","horizontalPanGestureHandler","verticalPanGestureHandler","debugGestureState","d"],"mappings":"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","sourcesContent":["import Animated from \"react-native-reanimated\";\nimport {\n  FlingGestureHandlerEventExtra,\n  ForceTouchGestureHandlerEventExtra,\n  GestureHandlerStateChangeNativeEvent,\n  LongPressGestureHandlerEventExtra,\n  PanGestureHandlerEventExtra,\n  PinchGestureHandlerEventExtra,\n  RotationGestureHandlerEventExtra,\n  State,\n  TapGestureHandlerEventExtra,\n} from \"react-native-gesture-handler\";\n\nimport { snapPoint } from \"./Animations\";\n\nconst {\n  Clock,\n  Value,\n  event,\n  add,\n  block,\n  cond,\n  eq,\n  multiply,\n  set,\n  stopClock,\n  and,\n  not,\n  clockRunning,\n  startClock,\n  neq,\n  call,\n  decay: reDecay,\n  spring: reSpring,\n  onChange,\n  debug,\n} = Animated;\n\nexport const withScaleOffset = (\n  value: Animated.Node<number>,\n  state: Animated.Node<State>,\n  offset: Animated.Value<number> = new Value(1)\n) =>\n  cond(\n    eq(state, State.END),\n    [set(offset, multiply(offset, value)), offset],\n    multiply(offset, value)\n  );\n\nexport const withOffset = (\n  value: Animated.Node<number>,\n  state: Animated.Node<State>,\n  offset: Animated.Value<number> = new Value(0)\n) =>\n  cond(\n    eq(state, State.END),\n    [set(offset, add(offset, value)), offset],\n    add(offset, value)\n  );\n\ninterface PrivateSpringConfig extends Animated.SpringConfig {\n  toValue: Animated.Value<number>;\n}\n\ntype SpringConfig = Omit<Animated.SpringConfig, \"toValue\">;\n\nexport interface WithSpringParams {\n  value: Animated.Adaptable<number>;\n  velocity: Animated.Adaptable<number>;\n  state: Animated.Node<State>;\n  snapPoints: Animated.Adaptable<number>[];\n  offset?: Animated.Value<number>;\n  config?: SpringConfig;\n  onSnap?: (value: readonly number[]) => void;\n}\n\nexport const withSpring = (props: WithSpringParams) => {\n  const {\n    value,\n    velocity,\n    state,\n    snapPoints,\n    offset,\n    config: springConfig,\n    onSnap,\n  } = {\n    offset: new Value(0),\n    ...props,\n  };\n  const clock = new Clock();\n  const springState: Animated.SpringState = {\n    finished: new Value(0),\n    velocity: new Value(0),\n    position: new Value(0),\n    time: new Value(0),\n  };\n\n  const config: PrivateSpringConfig = {\n    toValue: new Value(0),\n    damping: 6,\n    mass: 1,\n    stiffness: 64,\n    overshootClamping: false,\n    restSpeedThreshold: 0.01,\n    restDisplacementThreshold: 0.01,\n    ...springConfig,\n  };\n\n  const gestureAndAnimationIsOver = new Value(1);\n  const isSpringInterrupted = and(eq(state, State.BEGAN), clockRunning(clock));\n  const finishSpring = [\n    set(offset, springState.position),\n    stopClock(clock),\n    set(gestureAndAnimationIsOver, 1),\n  ];\n  const snap = onSnap\n    ? [cond(clockRunning(clock), call([springState.position], onSnap))]\n    : [];\n  return block([\n    cond(isSpringInterrupted, finishSpring),\n    cond(gestureAndAnimationIsOver, set(springState.position, offset)),\n    cond(neq(state, State.END), [\n      set(gestureAndAnimationIsOver, 0),\n      set(springState.finished, 0),\n      set(springState.position, add(offset, value)),\n    ]),\n    cond(and(eq(state, State.END), not(gestureAndAnimationIsOver)), [\n      cond(and(not(clockRunning(clock)), not(springState.finished)), [\n        set(springState.velocity, velocity),\n        set(springState.time, 0),\n        set(\n          config.toValue,\n          snapPoint(springState.position, velocity, snapPoints)\n        ),\n        startClock(clock),\n      ]),\n      reSpring(clock, springState, config),\n      cond(springState.finished, [...snap, ...finishSpring]),\n    ]),\n    springState.position,\n  ]);\n};\n\ninterface WithDecayParams {\n  value: Animated.Adaptable<number>;\n  velocity: Animated.Adaptable<number>;\n  state: Animated.Node<State>;\n  offset?: Animated.Value<number>;\n  deceleration?: number;\n}\n\nexport const withDecay = (config: WithDecayParams) => {\n  const { value, velocity, state, offset, deceleration } = {\n    offset: new Value(0),\n    deceleration: 0.998,\n    ...config,\n  };\n  const clock = new Clock();\n  const decayState = {\n    finished: new Value(0),\n    velocity: new Value(0),\n    position: new Value(0),\n    time: new Value(0),\n  };\n\n  const isDecayInterrupted = and(eq(state, State.BEGAN), clockRunning(clock));\n  const finishDecay = [set(offset, decayState.position), stopClock(clock)];\n\n  return block([\n    cond(isDecayInterrupted, finishDecay),\n    cond(neq(state, State.END), [\n      set(decayState.finished, 0),\n      set(decayState.position, add(offset, value)),\n    ]),\n    cond(eq(state, State.END), [\n      cond(and(not(clockRunning(clock)), not(decayState.finished)), [\n        set(decayState.velocity, velocity),\n        set(decayState.time, 0),\n        startClock(clock),\n      ]),\n      reDecay(clock, decayState, { deceleration }),\n      cond(decayState.finished, finishDecay),\n    ]),\n    decayState.position,\n  ]);\n};\n\nexport const onScrollEvent = (contentOffset: {\n  x?: Animated.Node<number>;\n  y?: Animated.Node<number>;\n}) =>\n  event([\n    {\n      nativeEvent: {\n        contentOffset,\n      },\n    },\n  ]);\n\ntype NativeEvent = GestureHandlerStateChangeNativeEvent &\n  (\n    | PanGestureHandlerEventExtra\n    | TapGestureHandlerEventExtra\n    | LongPressGestureHandlerEventExtra\n    | RotationGestureHandlerEventExtra\n    | FlingGestureHandlerEventExtra\n    | PinchGestureHandlerEventExtra\n    | ForceTouchGestureHandlerEventExtra\n  );\n\ntype Adaptable<T> = { [P in keyof T]: Animated.Adaptable<T[P]> };\n\nexport const onGestureEvent = (\n  nativeEvent: Partial<Adaptable<NativeEvent>>\n) => {\n  const gestureEvent = event([{ nativeEvent }]);\n  return {\n    onHandlerStateChange: gestureEvent,\n    onGestureEvent: gestureEvent,\n  };\n};\n\nexport const panGestureHandler = () => {\n  const x = new Value(0);\n  const translationX = new Value(0);\n  const velocityX = new Value(0);\n  const y = new Value(0);\n  const translationY = new Value(0);\n  const velocityY = new Value(0);\n  const state = new Value(State.UNDETERMINED);\n  const gestureHandler = onGestureEvent({\n    x,\n    translationX,\n    velocityX,\n    y,\n    translationY,\n    velocityY,\n    state,\n  });\n  return {\n    x,\n    translationX,\n    velocityX,\n    y,\n    translationY,\n    velocityY,\n    state,\n    gestureHandler,\n  };\n};\n\nexport const horizontalPanGestureHandler = () => {\n  const x = new Value(0);\n  const translationX = new Value(0);\n  const velocityX = new Value(0);\n  const state = new Value(State.UNDETERMINED);\n  const gestureHandler = onGestureEvent({\n    translationX,\n    velocityX,\n    state,\n  });\n  return {\n    x,\n    translationX,\n    state,\n    velocityX,\n    gestureHandler,\n  };\n};\n\nexport const verticalPanGestureHandler = () => {\n  const y = new Value(0);\n  const translationY = new Value(0);\n  const velocityY = new Value(0);\n  const state = new Value(State.UNDETERMINED);\n  const gestureHandler = onGestureEvent({\n    y,\n    translationY,\n    velocityY,\n    state,\n  });\n  return {\n    y,\n    translationY,\n    state,\n    velocityY,\n    gestureHandler,\n  };\n};\n\nexport const debugGestureState = (\n  label: string,\n  state: Animated.Node<State>\n) => {\n  const d = (value: string): Animated.Node<number> =>\n    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n    // @ts-ignore\n    debug(label, new Value(value));\n  return onChange(\n    state,\n    cond(\n      eq(state, State.UNDETERMINED),\n      d(\"UNDETERMINED\"),\n      cond(\n        eq(state, State.BEGAN),\n        d(\"BEGAN\"),\n        cond(\n          eq(state, State.ACTIVE),\n          d(\"ACTIVE\"),\n          cond(\n            eq(state, State.END),\n            d(\"END\"),\n            cond(eq(state, State.CANCELLED), d(\"CANCELLED\"), d(\"FAILED\"))\n          )\n        )\n      )\n    )\n  );\n};\n"]},"metadata":{},"sourceType":"module"}